<!DOCTYPE HTML>
<html lang="ja">
<head>
    <title>Sticker Studio | STICKER ARCHIVE</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    <style>
        html, body, #wrapper {
            margin: 0 !important;
            padding: 0 !important;
            height: 100vh !important;
            width: 100vw !important;
            background: #ebdef0;
            overflow: hidden;
            font-family: sans-serif;
        }

        .panel.full-screen {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            min-height: 100vh !important;
            max-width: none !important;
            margin: 0 !important;
            padding: 10px !important;
            border-radius: 0 !important;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        #sticker-editor {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            margin-top: 5px;
            width: 100%;
        }

        @media screen and (max-width: 980px) {
            #sticker-editor { flex-direction: column; align-items: center; overflow-y: auto; }
            .panel.full-screen { position: relative !important; height: auto !important; overflow-y: auto; }
        }

        .editor-canvas-wrapper {
            position: relative;
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #canvas {
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            touch-action: none;
            max-width: 100%;
            max-height: 75vh;
        }

        .editor-controls {
            flex: 1;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 85vh;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.15);
            padding: 15px;
            border-radius: 10px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #1a085e;
        }

        #contextMenu {
            display: none;
            position: fixed;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 10000;
            color: #333;
        }

        .menu-item { padding: 10px 20px; cursor: pointer; }
        .menu-item:hover { background: #007bff; color: #fff; }

        .text-tool-inputs { display: flex; flex-direction: column; gap: 8px; }
        .text-tool-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    </style>
</head>
<body class="is-preload">

    <div id="wrapper">
        <section class="panel full-screen">
            <div class="content">
                <header>
                    <h2 class="major" style="color:#1a085a !important;">Sticker Studio</h2>
                </header>

                <div id="sticker-editor">
                    <div class="editor-canvas-wrapper">
                        <canvas id="canvas" width="600" height="600"></canvas>
                        <div id="contextMenu">
                            <div class="menu-item" id="menuGroup">グループ化</div>
                            <div class="menu-item" id="menuUngroup">グループ解除</div>
                        </div>
                    </div>

                    <div class="editor-controls">
                        <div class="control-group">
                            <label>Text Tool</label>
                            <div class="text-tool-inputs">
                                <input type="text" id="text-input" placeholder="文字を入力..." />
                                <div class="text-tool-row">
                                    <input type="color" id="text-color" value="#000000" style="width:40px; height:40px; border:none;">
                                    <select id="text-font" style="flex:1;">
                                        <option value="sans-serif">Sans-serif</option>
                                        <option value="serif">Serif</option>
                                        <option value="cursive">Cursive</option>
                                        <option value="monospace">Monospace</option>
                                    </select>
                                    <button id="add-text" class="button primary small">Add</button>
                                </div>
                                <div class="text-tool-row">
                                    <label style="font-size: 0.7rem;">縁色</label>
                                    <input type="color" id="text-stroke-color" value="#ffffff" style="width:30px; height:30px; border:none;">
                                    <label style="font-size: 0.7rem;">太さ</label>
                                    <input type="range" id="text-stroke-width" min="0" max="10" value="0" style="flex:1;">
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Image & Layers</label>
                            <div style="display:flex; gap:10px;">
                                <button id="add-image-btn" class="button small">Image</button>
                                <input type="file" id="image-input" accept="image/*" style="display:none;" />
                                <button id="delete-item" class="button small icon solid fa-trash">Del</button>
                            </div>
                            <label>Layer Order</label>
                            <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                                <button id="layer-to-front" class="button small">最前面へ</button>
                                <button id="layer-forward" class="button small">前面へ</button>
                                <button id="layer-backward" class="button small">背面へ</button>
                                <button id="layer-to-back" class="button small">最背面へ</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>AI Magic</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <button id="ai-remove-bg" class="button small fit" style="background-color: #eb96e7 !important; color: #fff !important;">Remove BG</button>
                                <button id="ai-silhouette" class="button small fit" style="background-color: #ec8ffe !important; color: #fff !important;">Silhouette</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Canvas & Draw</label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                                <span style="font-size:0.7rem;">背景:</span>
                                <input type="color" id="bg-color" value="#f9f9f9" style="width:40px; height:30px;">
                                <button id="draw-mode-btn" class="button small">手書き: OFF</button>
                            </div>
                            <div id="brush-settings" style="display:none; flex-direction: column; gap: 8px; background: rgba(0,0,0,0.1); padding: 10px; border-radius: 5px;">
                                <div class="text-tool-row">
                                    <label style="font-size:0.7rem;">太さ</label>
                                    <input type="range" id="brush-size" min="1" max="50" value="5" style="flex:1;">
                                </div>
                                <div class="text-tool-row">
                                    <label style="font-size:0.7rem;">質感</label>
                                    <select id="brush-type" style="flex:1;">
                                        <option value="pencil">鉛筆</option>
                                        <option value="brush">筆 (ぼかし)</option>
                                        <option value="spray">スプレー</option>
                                        <option value="marker">マーカー</option>
                                    </select>
                                    <button id="brush-pencil" class="button small primary">ペン</button>
                                    <button id="brush-eraser" class="button small">消しゴム</button>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>System</label>
                            <div style="display:flex; gap:10px;">
                                <button id="undo" class="button small">Undo</button>
                                <button id="export" class="button primary small icon solid fa-download">Save</button>
                            </div>
                        </div>

                        <ul class="actions" style="margin-top: 1rem;">
                            <li><button id="post-gallery" class="button primary icon solid fa-cloud-upload-alt">Post</button></li>
                            <button id="download-image" class="button primary small icon solid fa-save">pngとして保存</button>
                            <li><a href="index.html" class="button small">Back</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/browser.min.js"></script>
    <script src="assets/js/breakpoints.min.js"></script>
    <script src="assets/js/main.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

    <script type="module">
        // Firebase設定（他のページと同じものをここに記述してください）
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        // ここにご自身の firebaseConfig を貼り付け
        const firebaseConfig = { 
            apiKey: "AIzaSyB8KXY15FWlENk7aohJM9D3-ZRkGqAhv7g",
            authDomain: "sticker-archive.firebaseapp.com",
            projectId: "sticker-archive",
            storageBucket: "sticker-archive.firebasestorage.app",
            messagingSenderId: "868816157027",
            appId: "1:868816157027:web:900f1deff73e823251bb56"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth();

        const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d");
        const contextMenu = document.getElementById("contextMenu");
        const CANVAS_SIZE = 600;
        const SNAP_THRESHOLD = 5;

        let layers = [], history = [], selectedIndices = [];
        let isDragging = false, isResizing = false, isRotating = false, isDrawing = false;
        let offsetX, offsetY, currentAiMode = "";
        let startMouseAngle, startLayerAngle;
        let isDrawMode = false, currentPath = null;
        let isEraserMode = false;

        // ★ログインユーザー情報を保持するグローバル変数
        let currentUserEmail = "";
        let currentUserName = "";

        // ★ログイン状態の監視
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUserEmail = user.email;
                currentUserName = user.displayName || "名無しさん";
            }
        });

        // --- 復元処理 ---
        window.onload = async () => {
            const urlParams = new URLSearchParams(window.location.search);
            let dataToLoad = null;
            let savedBgColor = "#f9f9f9"; // デフォルト値

            // 1. 再編集モードの判定とデータの取得
            const editId = urlParams.get('id');
            if (editId !== null) {
                const allProjects = JSON.parse(localStorage.getItem("projects")) || [];
                const project = allProjects[editId];
                if (project) {
                    dataToLoad = project.layers;
                    // 保存された背景色があれば取得
                    if (project.backgroundColor) {
                        savedBgColor = project.backgroundColor;
                    }
                }
            }

            // 2. テンプレートモードの判定
            if (urlParams.get('template') === 'true') {
                const temp = localStorage.getItem("templateData");
                if (temp) dataToLoad = JSON.parse(temp);
            }

            // 背景色をUIとキャンバスに即時反映
            document.getElementById("bg-color").value = savedBgColor;
            canvas.style.backgroundColor = savedBgColor;

            if (dataToLoad) {
                // 3. 全レイヤー（グループ内を含む）の画像読み込み関数
                const loadImage = (layerObj, srcPath) => {
                    return new Promise(resolve => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => { 
                            layerObj.img = img; 
                            // imageタイプの場合のみoriginalImgも復元
                            if(layerObj.type === 'image') layerObj.originalImg = img;
                            resolve(); 
                        };
                        img.onerror = () => { 
                            console.error("画像の読み込みに失敗しました:", srcPath); 
                            resolve(); 
                        };
                        img.src = srcPath;
                    });
                };

                const loadPromises = [];

                // レイヤーを走査してプロミスを収集
                dataToLoad.forEach(l => {
                    if (l.type === 'image') {
                        loadPromises.push(loadImage(l, l.img));
                    } else if (l.type === 'group' && l.children) {
                        // グループ内の画像もすべてチェック
                        l.children.forEach(c => {
                            if (c.type === 'image') {
                                loadPromises.push(loadImage(c, c.img));
                            }
                        });
                    }
                });

                try {
                    // すべての画像の読み込み完了を待機
                    await Promise.all(loadPromises);
                    
                    // データをグローバル変数に反映
                    layers = dataToLoad;

                    // 背景色を最終確定（描画直前に念のため再セット）
                    canvas.style.backgroundColor = savedBgColor;
                    document.getElementById("bg-color").value = savedBgColor;

                    // キャンバスに描画実行
                    drawSticker();
                } catch (err) { 
                    console.error("復元中にエラーが発生しました:", err); 
                }
            }
        };

        function saveHistory() {
            const state = JSON.parse(JSON.stringify(layers, (k, v) => (k === 'img' || k === 'originalImg' ? v.src : v)));
            history.push(state);
            if (history.length > 20) history.shift();
        }

        function getLayerMetrics(l) {
            if (l.type === 'image') return { width: l.img.width * l.scaleX, height: l.img.height * l.scaleY };
            if (l.type === 'text') {
                ctx.save();
                ctx.font = `bold 60px ${l.font}`;
                const w = ctx.measureText(l.text).width * l.scaleX;
                ctx.restore();
                return { width: w, height: 60 * l.scaleY };
            }
            if (l.type === 'group') return { width: l.width * l.scaleX, height: l.height * l.scaleY };
            return { width: 0, height: 0 };
        }

        function drawSticker() {
        // 1. キャンバスのクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 2. 背景色の描画（保存時や読み込み時に白くなるのを防ぐ）
        const bgColor = document.getElementById("bg-color").value;
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 3. 中心ガイド線の描画（何かを選択している時のみ表示）
        if (selectedIndices.length > 0) {
            ctx.save();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = "rgba(0, 123, 255, 0.5)";
            ctx.lineWidth = 1;
            
            // 垂直線
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            
            // 水平線
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.restore();
        }

        // 4. 各レイヤーの描画
        layers.forEach((l, idx) => {
            ctx.save();
            
            // パス（手書き）レイヤーの処理
            if (l.type === 'path') {
                if (l.points.length < 2) { ctx.restore(); return; }
                ctx.globalCompositeOperation = l.isEraser ? 'destination-out' : 'source-over';
                ctx.lineWidth = l.width; ctx.lineJoin = "round"; ctx.lineCap = "round";
                if (!l.isEraser) {
                    ctx.strokeStyle = l.color;
                    if (l.brushType === 'brush') { ctx.globalAlpha = 0.6; ctx.shadowBlur = l.width/2; ctx.shadowColor = l.color; }
                    else if (l.brushType === 'spray') { ctx.setLineDash([1, l.width * 1.5]); }
                    else if (l.brushType === 'marker') { ctx.globalAlpha = 0.4; }
                }
                ctx.beginPath(); ctx.moveTo(l.points[0].x, l.points[0].y);
                l.points.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();
            } 
            // 画像・テキスト・グループレイヤーの処理
            else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.translate(l.x, l.y); 
                ctx.rotate(l.angle || 0);
                const m = getLayerMetrics(l);

                if (l.type === 'image') {
                    ctx.drawImage(l.img, -m.width/2, -m.height/2, m.width, m.height);
                } 
                else if (l.type === 'text') {
                    ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.font = `bold ${60 * l.scaleY}px ${l.font}`;
                    if (l.strokeWidth > 0) {
                        ctx.strokeStyle = l.strokeColor; 
                        ctx.lineWidth = l.strokeWidth * l.scaleY;
                        ctx.lineJoin = "round"; 
                        ctx.strokeText(l.text, 0, 0);
                    }
                    ctx.fillStyle = l.color; ctx.fillText(l.text, 0, 0);
                } 
                else if (l.type === 'group') {
                    // グループ内の子要素を描画
                    l.children.forEach(c => {
                        ctx.save();
                        // グループ内の相対座標へ移動（グループのスケールを適用）
                        ctx.translate(c.relX * l.scaleX, c.relY * l.scaleY);
                        ctx.rotate(c.angle || 0);
                        
                        const cm = getLayerMetrics(c);
                        
                        // 子要素：画像（先に描画して背景にする）
                        if (c.type === 'image') {
                            if (c.img) {
                                ctx.drawImage(
                                    c.img, 
                                    -cm.width * l.scaleX / 2, 
                                    -cm.height * l.scaleY / 2, 
                                    cm.width * l.scaleX, 
                                    cm.height * l.scaleY
                                );
                            }
                        } 
                        // 子要素：テキスト（画像の上に重ねる）
                        else if (c.type === 'text') {
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.font = `bold ${60 * c.scaleY * l.scaleY}px ${c.font}`;

                            // グループ内テキストの縁取り
                            if (c.strokeWidth > 0) {
                                ctx.strokeStyle = c.strokeColor || "#ffffff";
                                ctx.lineWidth = c.strokeWidth * c.scaleY * l.scaleY;
                                ctx.lineJoin = "round";
                                ctx.strokeText(c.text, 0, 0);
                            }
                            ctx.fillStyle = c.color;
                            ctx.fillText(c.text, 0, 0);
                        }
                        ctx.restore();
                    });
                }

                // 5. 選択中の枠線とハンドルの描画
                if (selectedIndices.includes(idx)) {
                    ctx.strokeStyle = "#007bff";
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    // 枠線
                    ctx.strokeRect(-m.width / 2 - 5, -m.height / 2 - 5, m.width + 10, m.height + 10);
                    ctx.setLineDash([]);
                    
                    // 回転ハンドル
                    ctx.fillStyle = "#007bff";
                    ctx.beginPath();
                    ctx.moveTo(0, -m.height / 2 - 5);
                    ctx.lineTo(0, -m.height / 2 - 30);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, -m.height / 2 - 30, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // リサイズハンドル（右下）
                    ctx.fillRect(m.width / 2, m.height / 2, 10, 10);
                }
            }
            ctx.restore();
        });
    }

        // ★ A. マイページへ保存（修正の核心）
        document.getElementById("export").onclick = () => {
            const user = auth.currentUser;
            const email = user ? user.email : localStorage.getItem("currentUserEmail");
            const name = user ? user.displayName : localStorage.getItem("currentUser");

            if (!email) {
                alert("保存するにはログインが必要です。");
                return;
            }

            const title = prompt("作品のタイトルを入力してください", "無題のステッカー");
            if (title === null) return;

            // 高速・軽量化のためにwebp形式を利用
            const imageData = canvas.toDataURL("image/webp", 0.7);
            const newProject = {
                owner: name || "名無しさん",
                ownerId: email, // 判定用メールアドレス
                title: title,
                imageData: imageData,
                date: new Date().toLocaleString(),
                backgroundColor: document.getElementById("bg-color").value,
                layers: JSON.parse(JSON.stringify(layers, (k, v) => (k === 'img' || k === 'originalImg' ? v.src : v)))
            };

            let allProjects = JSON.parse(localStorage.getItem("projects")) || [];
            const urlParams = new URLSearchParams(window.location.search);
            const editId = urlParams.get('id');
            
            if (editId !== null && allProjects[editId]) {
                if (allProjects[editId].ownerId !== email) {
                    alert("この作品を上書きする権限がありません。");
                    return;
                }
                allProjects[editId] = newProject;
                alert("作品を更新しました！");
            } else {
                allProjects.push(newProject);
                alert("マイページに新しく保存しました！");
            }

            localStorage.setItem("projects", JSON.stringify(allProjects));
        };

        // ★ B. ギャラリーへ投稿（修正の核心）
        document.getElementById("post-gallery").onclick = () => {
        const user = auth.currentUser;
        const email = user ? user.email : localStorage.getItem("currentUserEmail");
        const name = user ? user.displayName : localStorage.getItem("currentUser");

        if (!email) {
            alert("投稿するにはログインが必要です。");
            return;
        }

        if (!confirm("この作品をギャラリーに公開しますか？")) return;

        // --- 1. 投稿用の見た目を整える（枠を消して背景を描画） ---
        const tempSelected = [...selectedIndices]; // 現在の選択を一時保存
        selectedIndices = []; 
        drawSticker(); // 背景色込み、枠なしの状態でキャンバスを更新

        // --- 2. 画像データと投稿データの生成 ---
        // 容量節約のため、少し画質を調整（0.7 -> 0.6）
        const imageData = canvas.toDataURL("image/webp", 0.6);
        
        const newPost = {
            author: name || "名無しさん",
            authorEmail: email,
            imageData: imageData,
            date: new Date().toLocaleString(),
            likes: 0,
            // ★追加：背景色情報を保存（テンプレートとして使った時に背景が消えないように）
            backgroundColor: document.getElementById("bg-color").value,
            layers: JSON.parse(JSON.stringify(layers, (k, v) => (k === 'img' || k === 'originalImg' ? v.src : v)))
        };

        // --- 3. localStorageへの保存処理（エラーハンドリング付き） ---
        try {
            let gallery = JSON.parse(localStorage.getItem("gallery")) || [];
            gallery.unshift(newPost);
            localStorage.setItem("gallery", JSON.stringify(gallery));

            alert("ギャラリーに投稿しました！");
            window.location.href = "works.html";
        } catch (e) {
            console.error("Storage Error:", e);
            if (e.name === 'QuotaExceededError') {
                alert("エラー: データの容量が大きすぎて投稿できません。画像を減らすか、タイトルを短くしてください。");
            } else {
                alert("投稿中に予期せぬエラーが発生しました。");
            }
            
            // エラー時は選択状態を戻して再描画
            selectedIndices = tempSelected;
            drawSticker();
        }
    };

        // --- マウス・タッチ操作ロジック ---
        canvas.onmousedown = (e) => {
            const r = canvas.getBoundingClientRect();
            const mx = (e.clientX - r.left) * (CANVAS_SIZE / r.width), my = (e.clientY - r.top) * (CANVAS_SIZE / r.height);

            if (isDrawMode) {
                saveHistory(); isDrawing = true;
                currentPath = { type: 'path', points: [{x:mx, y:my}], color: document.getElementById("text-color").value, width: parseInt(document.getElementById("brush-size").value), brushType: document.getElementById("brush-type").value, isEraser: isEraserMode };
                layers.push(currentPath); drawSticker(); return;
            }

            if (selectedIndices.length === 1) {
                const l = layers[selectedIndices[0]], m = getLayerMetrics(l);
                const cos = Math.cos(-l.angle), sin = Math.sin(-l.angle);
                const rx = (mx - l.x) * cos - (my - l.y) * sin, ry = (mx - l.x) * sin + (my - l.y) * cos;
                if (Math.abs(rx) < 15 && Math.abs(ry - (-m.height/2-30)) < 15) { isRotating = true; startMouseAngle = Math.atan2(my-l.y, mx-l.x); startLayerAngle = l.angle; return; }
                if (Math.abs(rx - m.width/2) < 15 && Math.abs(ry - m.height/2) < 15) { isResizing = true; return; }
            }

            let hit = -1;
            for (let i = layers.length-1; i >= 0; i--) {
                const l = layers[i]; if (l.type === 'path') continue;
                const m = getLayerMetrics(l);
                const cos = Math.cos(-l.angle), sin = Math.sin(-l.angle);
                const rx = (mx - l.x) * cos - (my - l.y) * sin, ry = (mx - l.x) * sin + (my - l.y) * cos;
                if (Math.abs(rx) < m.width/2 && Math.abs(ry) < m.height/2) { hit = i; break; }
            }

            if (hit !== -1) {
                if (e.shiftKey) { if (!selectedIndices.includes(hit)) selectedIndices.push(hit); }
                else { selectedIndices = [hit]; isDragging = true; 
                    const selectedLayer = layers[hit];
                    if (selectedLayer.type === 'text') {
                        document.getElementById("text-input").value = selectedLayer.text;
                        document.getElementById("text-color").value = selectedLayer.color;
                        document.getElementById("text-font").value = selectedLayer.font;
                        document.getElementById("text-stroke-color").value = selectedLayer.strokeColor || "#ffffff";
                        document.getElementById("text-stroke-width").value = selectedLayer.strokeWidth || 0;
                    }
                    offsetX = mx - layers[hit].x; offsetY = my - layers[hit].y; }
            } else { selectedIndices = []; }
            drawSticker();
        };

        window.onmousemove = (e) => {
            const r = canvas.getBoundingClientRect();
            const mx = (e.clientX - r.left) * (CANVAS_SIZE / r.width), my = (e.clientY - r.top) * (CANVAS_SIZE / r.height);
            if (isDrawing && currentPath) { currentPath.points.push({x:mx, y:my}); drawSticker(); }
            else if (isDragging) {
                let tx = mx - offsetX, ty = my - offsetY;
                if (Math.abs(tx - 300) < SNAP_THRESHOLD) tx = 300;
                if (Math.abs(ty - 300) < SNAP_THRESHOLD) ty = 300;
                layers[selectedIndices[0]].x = tx; layers[selectedIndices[0]].y = ty; drawSticker();
            } else if (isResizing) {
                const l = layers[selectedIndices[0]];
                l.scaleX = Math.max(0.1, Math.abs(mx - l.x)*2 / (l.type==='image'?l.img.width:100));
                l.scaleY = Math.max(0.1, Math.abs(my - l.y)*2 / (l.type==='image'?l.img.height:60));
                drawSticker();
            } else if (isRotating) {
                const l = layers[selectedIndices[0]];
                l.angle = startLayerAngle + (Math.atan2(my-l.y, mx-l.x) - startMouseAngle); drawSticker();
            }
        };

        window.onmouseup = () => { isDragging = isResizing = isRotating = isDrawing = false; currentPath = null; };

        // UIイベント
        document.getElementById("draw-mode-btn").onclick = (e) => {
            isDrawMode = !isDrawMode;
            document.getElementById("brush-settings").style.display = isDrawMode ? "flex" : "none";
            e.target.innerText = isDrawMode ? "✏️ 手書き: ON" : "✏️ 手書き: OFF";
            if (isDrawMode) selectedIndices = [];
            drawSticker();
        };

        document.getElementById("brush-pencil").onclick = () => { isEraserMode = false; };
        document.getElementById("brush-eraser").onclick = () => { isEraserMode = true; };

        document.getElementById("add-text").onclick = () => {
            saveHistory();
            layers.push({ type: 'text', text: document.getElementById("text-input").value || "TEXT", color: document.getElementById("text-color").value, font: document.getElementById("text-font").value, x: 300, y: 300, scaleX: 1, scaleY: 1, angle: 0, strokeColor: document.getElementById("text-stroke-color").value, strokeWidth: parseInt(document.getElementById("text-stroke-width").value) });
            drawSticker();
        };

        // テキストプロパティ（内容、色、フォント、縁、太さ）の即時反映
        ["text-input", "text-color", "text-font", "text-stroke-color", "text-stroke-width"].forEach(id => {
            const el = document.getElementById(id);
            
            el.addEventListener("input", () => {
                // 1つだけ選択されていて、それがテキストレイヤーの場合のみ実行
                if (selectedIndices.length === 1) {
                    const l = layers[selectedIndices[0]];
                    
                    if (l.type === 'text') {
                        // 各フォームの最新値をレイヤーに反映
                        l.text = document.getElementById("text-input").value;
                        l.color = document.getElementById("text-color").value;
                        l.font = document.getElementById("text-font").value;
                        l.strokeColor = document.getElementById("text-stroke-color").value;
                        l.strokeWidth = parseFloat(document.getElementById("text-stroke-width").value);
                        
                        // キャンバスを再描画して見た目を更新
                        drawSticker();
                    }
                }
            });

            // 変更が確定したタイミング（指を離した時など）で履歴に保存
            el.addEventListener("change", () => {
                if (selectedIndices.length === 1 && layers[selectedIndices[0]].type === 'text') {
                    saveHistory();
                }
            });
        });

        document.getElementById("add-image-btn").onclick = () => document.getElementById("image-input").click();
        document.getElementById("image-input").onchange = (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (f) => {
                const img = new Image(); img.crossOrigin = "anonymous";
                img.onload = () => {
                    saveHistory();
                    layers.push({ type: 'image', img: img, originalImg: img, x: 300, y: 300, scaleX: 0.5, scaleY: 0.5, angle: 0 });
                    drawSticker();
                };
                img.src = f.target.result;
            };
            reader.readAsDataURL(file);
        };

        document.getElementById("delete-item").onclick = () => { if (selectedIndices.length > 0) { saveHistory(); layers = layers.filter((_, i) => !selectedIndices.includes(i)); selectedIndices = []; drawSticker(); } };

        document.getElementById("undo").onclick = () => {
            if (history.length > 0) {
                const prevState = history.pop();
                const loadPromises = prevState.map(l => {
                    if (l.type === 'image') {
                        return new Promise(res => {
                            const img = new Image(); img.onload = () => { l.img = img; res(); }; img.src = l.img;
                        });
                    }
                    return Promise.resolve();
                });
                Promise.all(loadPromises).then(() => { layers = prevState; drawSticker(); });
            }
        };

        document.getElementById("bg-color").oninput = (e) => {
            // 1. キャンバス自体のCSS背景色を更新（プレビュー用）
            canvas.style.backgroundColor = e.target.value;
            
            // 2. 描画処理を実行して、キャンバス内部の背景塗りつぶしも更新
            drawSticker(); 
        };

        // テキストカラーの変更を即座に反映
        document.getElementById("text-color").oninput = (e) => {
            // 1つだけ選択されていて、それがテキストレイヤーの場合
            if (selectedIndices.length === 1) {
                const selectedLayer = layers[selectedIndices[0]];
                
                if (selectedLayer.type === 'text') {
                    // レイヤーの色情報を更新
                    selectedLayer.color = e.target.value;
                    // 再描画
                    drawSticker();
                }
            }
        };

        // 縁取り（ストローク）カラーも同様に即時反映したい場合
        document.getElementById("text-stroke-color").oninput = (e) => {
            if (selectedIndices.length === 1 && layers[selectedIndices[0]].type === 'text') {
                layers[selectedIndices[0]].strokeColor = e.target.value;
                drawSticker();
            }
        };

        const moveLayer = (direction) => {
            if (selectedIndices.length !== 1) return;
            const idx = selectedIndices[0]; const l = layers[idx]; saveHistory();
            if (direction === 'front') { layers.splice(idx, 1); layers.push(l); selectedIndices = [layers.length-1]; }
            else if (direction === 'back') { layers.splice(idx, 1); layers.unshift(l); selectedIndices = [0]; }
            else if (direction === 'forward' && idx < layers.length-1) { [layers[idx], layers[idx+1]] = [layers[idx+1], layers[idx]]; selectedIndices = [idx+1]; }
            else if (direction === 'backward' && idx > 0) { [layers[idx], layers[idx-1]] = [layers[idx-1], layers[idx]]; selectedIndices = [idx-1]; }
            drawSticker();
        };

        document.getElementById("layer-to-front").onclick = () => moveLayer('front');
        document.getElementById("layer-to-back").onclick = () => moveLayer('back');
        document.getElementById("layer-forward").onclick = () => moveLayer('forward');
        document.getElementById("layer-backward").onclick = () => moveLayer('backward');

        // AI Logic
        const ss = new SelfieSegmentation({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`});
        ss.setOptions({ modelSelection: 1 });
        ss.onResults((res) => {
            if (selectedIndices.length !== 1) return;
            const l = layers[selectedIndices[0]]; if (l.type !== 'image') return;
            const c = document.createElement("canvas"); c.width = l.originalImg.width; c.height = l.originalImg.height;
            const t = c.getContext("2d"); t.drawImage(res.segmentationMask, 0, 0, c.width, c.height);
            t.globalCompositeOperation = 'source-in';
            if (currentAiMode === "silhouette") { t.fillStyle = "#000"; t.fillRect(0,0,c.width,c.height); }
            else { t.drawImage(l.originalImg, 0, 0, c.width, c.height); }
            const ni = new Image(); ni.onload = () => { l.img = ni; drawSticker(); }; ni.src = c.toDataURL();
        });

        document.getElementById("ai-remove-bg").onclick = () => { currentAiMode = "remove"; ss.send({image: layers[selectedIndices[0]].originalImg}); };
        document.getElementById("ai-silhouette").onclick = () => { currentAiMode = "silhouette"; ss.send({image: layers[selectedIndices[0]].originalImg}); };

        // グループ化ロジック
        document.getElementById("menuGroup").onclick = () => {
        if (selectedIndices.length < 2) return;
        saveHistory();

        // 1. 選択されたインデックスを降順（大きい順）にソート
        const sortedIndices = [...selectedIndices].sort((a, b) => b - a);
        
        // 2. 選択されたレイヤーの中で、最も背面（最小）のインデックスを特定
        const targetInsertIndex = Math.min(...selectedIndices);

        // 3. 選択されたレイヤーを取得
        const selectedLayers = sortedIndices.map(i => layers[i]);

        // 4. グループの範囲（バウンディングボックス）を計算
        const rects = selectedLayers.map(l => {
            const m = getLayerMetrics(l);
            return { x1: l.x - m.width/2, x2: l.x + m.width/2, y1: l.y - m.height/2, y2: l.y + m.height/2 };
        });
        const minX = Math.min(...rects.map(r => r.x1)), maxX = Math.max(...rects.map(r => r.x2));
        const minY = Math.min(...rects.map(r => r.y1)), maxY = Math.max(...rects.map(r => r.y2));
        const groupX = (minX + maxX) / 2, groupY = (minY + maxY) / 2;

        // 5. 新しいグループオブジェクトの作成
        const newGroup = {
            type: 'group',
            x: groupX,
            y: groupY,
            width: maxX - minX,
            height: maxY - minY,
            scaleX: 1,
            scaleY: 1,
            angle: 0,
            // 元の順序を維持するために、選択レイヤーを反転させて子要素にする
            children: sortedIndices.map(i => {
            const l = layers[i];
            return {
                ...l, // 全てのプロパティ（text, color, strokeWidth, strokeColor等）をコピー
                relX: l.x - groupX,
                relY: l.y - groupY
            };
        }).reverse() // 重なり順を維持するために逆順にする
    };

        // 6. 元のレイヤーを削除（大きいインデックスから消す）
        sortedIndices.forEach(i => layers.splice(i, 1));

        // 7. 【重要】元の重なり順（targetInsertIndex）にグループを挿入
        layers.splice(targetInsertIndex, 0, newGroup);

        // 8. 選択状態を更新して再描画
        selectedIndices = [targetInsertIndex];
        drawSticker();
    };

        // グループ化解除ボタンのイベント
        document.getElementById("menuUngroup").onclick = () => {
            // 1つだけ選択されており、かつそれがグループタイプであること
            if (selectedIndices.length !== 1 || layers[selectedIndices[0]].type !== 'group') return;

            const idx = selectedIndices[0];
            const g = layers[idx]; // グループ本体
            saveHistory();

            // グループ内の子要素を、グループの現在の状態（位置・回転・拡大）を反映させて取り出す
            g.children.forEach(c => {
                const cos = Math.cos(g.angle || 0);
                const sin = Math.sin(g.angle || 0);

                // 1. グループの回転と拡大率を反映した相対座標の計算
                const rx = (c.relX * g.scaleX) * cos - (c.relY * g.scaleY) * sin;
                const ry = (c.relX * g.scaleX) * sin + (c.relY * g.scaleY) * cos;

                // 2. 新しいレイヤーとして追加（グループの値を合算する）
                layers.push({
                    ...c,
                    x: g.x + rx,                          // グループの中心座標 + 回転後の相対座標
                    y: g.y + ry,
                    scaleX: c.scaleX * g.scaleX,          // 子の拡大率 × グループの拡大率
                    scaleY: c.scaleY * g.scaleY,
                    angle: (c.angle || 0) + (g.angle || 0) // 子の角度 + グループの角度
                });
            });

            // 3. 元のグループを削除
            layers.splice(idx, 1);
            
            // 選択を解除して再描画
            selectedIndices = [];
            drawSticker();
        };

        document.getElementById("download-image").onclick = () => {
        // 1. 選択を一時的に解除（青い枠やハンドルが写らないようにする）
        const tempSelected = [...selectedIndices];
        selectedIndices = [];
        drawSticker();

        // 2. 背景色を反映させるための一時的なキャンバスを作成
        const outputCanvas = document.createElement("canvas");
        outputCanvas.width = canvas.width;
        outputCanvas.height = canvas.height;
        const oCtx = outputCanvas.getContext("2d");

        // 3. 背景色を塗る
        const bgColor = document.getElementById("bg-color").value;
        oCtx.fillStyle = bgColor;
        oCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

        // 4. メインキャンバスの内容を重ねる
        oCtx.drawImage(canvas, 0, 0);

        // 5. ダウンロード実行
        const link = document.createElement('a');
        link.download = 'sticker-creation.png'; // ファイル名
        link.href = outputCanvas.toDataURL("image/png");
        link.click();

        // 6. 選択状態を元に戻して再描画
        selectedIndices = tempSelected;
        drawSticker();
        
        alert("画像をデバイスに保存しました！");
    };

        canvas.oncontextmenu = (e) => {
            e.preventDefault(); if (selectedIndices.length === 0) return;
            contextMenu.style.display = "block"; contextMenu.style.left = e.clientX + "px"; contextMenu.style.top = e.clientY + "px";
            document.getElementById("menuGroup").style.display = selectedIndices.length >= 2 ? "block" : "none";
            document.getElementById("menuUngroup").style.display = (selectedIndices.length === 1 && layers[selectedIndices[0]].type === 'group') ? "block" : "none";
        };
        window.onclick = () => { contextMenu.style.display = "none"; };
    </script>
</body>
</html>